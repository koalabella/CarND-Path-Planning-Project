#include <algorithm>
#include <cmath>
#include <math.h>
#include <map>
#include <iostream>
#include <vector>
#include "cost.h"
#include "global.h"
#include "helper.h"
#include "vehicle.h"

using namespace std;

Vehicle::Vehicle(string state) {
    this->state = state;
}

void Vehicle::set_map(vector<double> map_waypoints_x, vector<double> map_waypoints_y,
                      vector<double> map_waypoints_s) {
    this->map_waypoints_x = map_waypoints_x;
    this->map_waypoints_y = map_waypoints_y;
    this->map_waypoints_s = map_waypoints_s;
}

void Vehicle::set_current(double x, double y, double s, double d,
                          double yaw, double vs, int pred_num) {
    this->x = x;
    this->y = y;
    this->s = s;
    this->d = d;
    this->yaw = yaw;
    this->vs = vs;
    this->cur_lane = int(d/4);

    this->pred_num = pred_num;
    return;
}

//positions of the car's newes trajectory point generated by previous cycle.
void Vehicle::set_ref(double ref_x, double ref_y, double ref_vx, double ref_vy) {
    this->ref_x = ref_x;
    this->ref_y = ref_y;
    this->ref_vx = ref_vx;
    this->ref_vy = ref_vy;

    this->ref_yaw = atan2(ref_vy, ref_vx);
    this->ref_vs = sqrt(ref_vx * ref_vx + ref_vy * ref_vy);

    vector<double> ref_sd = getFrenet(ref_x, ref_y, ref_yaw, map_waypoints_x, map_waypoints_y);
    this->ref_s = ref_sd[0];
    this->ref_d = ref_sd[1];

    this->ref_lane = int(ref_d/4);
    return;
}

void Vehicle::set_rc_ref(double ref_s, double ref_d, double ref_vs) {
    this->ref_s = ref_s;
    this->ref_d = ref_d;
    this->ref_vs = ref_vs;

    this->ref_lane = int(ref_d/4);
}
vector<vector<double>> Vehicle::decide_next_state(const map<int, Vehicle> &round_vehicles) {
    cout << "new cycle" << endl;
    vector<string> states;
    states = sucessor_states();
    double min_cost = -1;
    string best_state;
    vector<vector<double>> best_traj;

    vector<vector<vector<double>>> possible_trajs;
    for (auto state:states) {
        this->state = state;
        possible_trajs = gen_trajectory(state, round_vehicles);
        for (auto &traj:possible_trajs) {
            double cost = calculate_costs(*this, round_vehicles, traj);
            cout << "state: " << state << " and total cost: " << cost << endl;

            if (min_cost < 0 || cost < min_cost) {
                min_cost = cost;
                best_state = state;
                best_traj = traj;
            }
        }
    }
    cout << "best state: " << best_state << " and best cost: " << min_cost << endl;
    this->state = best_state;

/*    cout << "moving strategy: " << best_state <<endl;

    //generate final trajectory from best trajectory parameters.
    vector<double> s_para = best_traj[0];
    vector<double> d_para = best_traj[1];
    for (int i = 0; i < s_para.size(); i++) {
        cout << "s_para" << s_para[i] << endl;
        cout << "d_para" << d_para[i] << endl;
    }
*/
    return best_traj;
}

vector<string> Vehicle::sucessor_states() {
    //cout << "successor_states" << endl;
    vector<string> states;
    bool no_keep_lane = false;
    string state = this->state;
    if(state.compare("KL") == 0) {
        if (ref_lane > 0)
            states.push_back("PLCL");
        if (ref_lane < 2)
            states.push_back("PLCR");
    } else if (state.compare("PLCL") == 0) {
        if (this->ref_lane != 0) {
            states.push_back("PLCL");
            states.push_back("LCL");
        }
    } else if (state.compare("PLCR") == 0) {
        if (this->ref_lane != LANES_NUM - 1) {
            states.push_back("PLCR");
            states.push_back("LCR");
        }
    } else if (state.compare("LCL") == 0) {
        if (this->ref_lane == this->cur_lane) { //not finish lane change yet
            states.push_back("LCL");
            no_keep_lane = true;
        } else no_keep_lane = false;//else just keep lane, already in the possible state vector
    } else if (state.compare("LCR") == 0) {
        if (this->ref_lane == this->cur_lane) { //not finish lane change yet
            states.push_back("LCR");
            no_keep_lane = true;
        } else no_keep_lane = false;
    }
    states.push_back("KL");
/*    if (!no_keep_lane)
        states.push_back("KL");*/
    return states;
}

vector<vector<vector<double>>> Vehicle::gen_trajectory(string next_state,
                                                       const map<int, Vehicle> & round_vehicles) {

    vector<vector<vector<double>>> trajectory_points;
    //trajectory_points = keep_lane_trajectory(round_vehicles);

    if (next_state.compare("KL") == 0) {
        trajectory_points = keep_lane_trajectory(round_vehicles);
    } else if (next_state.compare("LCL") == 0 || next_state.compare("LCR") == 0) {
        trajectory_points = lane_change_trajectory(next_state, round_vehicles);
    } else if (next_state.compare("PLCL") == 0 || next_state.compare("PLCR") == 0) {
        trajectory_points = prep_lane_change_trajectory(next_state, round_vehicles);
    }
    return trajectory_points;
}

vector<vector<vector<double>>> Vehicle::keep_lane_trajectory(const map<int, Vehicle> &round_vehicles) {
    /*
    Generate parameters of a keep lane trajectory.
    */
    vector<vector<vector<double>>> traj_set;
    vector<vector<vector<double>>> goals_sets = get_goal_positions(round_vehicles, this->ref_lane);

    double goal_vs = ref_vs;
    Vehicle ahead;

    //if approaching to ahead car, slow down
    //else, speed up.
    if (get_vehicle_ahead(round_vehicles, this->ref_lane, ahead) &&
        (ahead.ref_s - this->ref_s) < 30) {
            double extra_dec = 0.2* max(0.0, this->ref_vs -ahead.ref_vs);
            goal_vs = max(0.0, goal_vs - 0.2 * ( 1+ extra_dec));
    } else if (goal_vs < TARGET_SPEED - 0.3)
        goal_vs += 0.2;

/*    if (goal_vs < TARGET_SPEED)
        goal_vs += 1;*/

    traj_set = trajectory_points(goals_sets, goal_vs);

    return traj_set;
}

vector<vector<vector<double>>> Vehicle::prep_lane_change_trajectory(string state,
                                                                    const map<int, Vehicle> &round_vehicles) {
    /*
    Generate a trajectory preparing for a lane change.
    */
    cout << "prep_lane_change_trajectory" << endl;
    vector<vector<vector<double>>> traj_set;

    Vehicle vehicle_behind;
    vector<vector<vector<double>>> goals = get_goal_positions(round_vehicles, this->ref_lane);

    double goal_vs = ref_vs;
    Vehicle ahead, ahead_next_lane, behind_next_lane;

    if (get_vehicle_ahead(round_vehicles, heading_lane(), ahead_next_lane) &&
        (ahead_next_lane.ref_s - this->ref_s) < 40) {
        //if in the target lane, there is a car ahead, try to speed up or slow down wait it go away;

        cout << "next line have ahead vehicle" << endl;
        // if in both lane there are car ahead and they were close,
        //then just stay in the current lane and slow down.
        if (get_vehicle_ahead(round_vehicles, this->ref_lane, ahead) &&
                              (ahead.ref_s - this->ref_s) < 40) {
            cout << "too close" << endl;
            double extra_dec = 0.1 * max(0.0, this->ref_vs -ahead.ref_vs);
            goal_vs = max(0.0, goal_vs -  0.2 * (1 + extra_dec));
        }
        else  //speed up to pass the next lane ahead car.
            cout << "speed up" << endl;
            goal_vs = min(goal_vs + 0.1, TARGET_SPEED);

    } else if (get_vehicle_behind(round_vehicles, heading_lane(), behind_next_lane)) {
        cout << "next line have behind vehicle" << endl;
        cout << get_vehicle_ahead(round_vehicles, this->ref_lane, ahead) << endl;

        //1.if in the target lane, there is a car behind and close, stay in current lane and do nothing.
        //2.if in the target lane, there is a car behind and not so close, speed up
        if (get_vehicle_ahead(round_vehicles, this->ref_lane, ahead) &&
                              (ahead.ref_s - this->ref_s) < 40) {
            cout << "too close" << endl;
            double extra_dec = 0.1 * max(0.0, this->ref_vs -ahead.ref_vs);
            goal_vs = max(0.0, goal_vs -  0.2 * (1 + extra_dec));
        } else if ((this->ref_s - behind_next_lane.ref_s) >= 20) {  //case2
            cout << "speed up" << endl;
            goal_vs = min(goal_vs + 1, TARGET_SPEED);
        } else
            goal_vs = max(0.0, goal_vs -  0.1);

    } else if (get_vehicle_ahead(round_vehicles, this->ref_lane, ahead) &&
              (ahead.ref_s - this->ref_s) < 40) {
        double extra_dec = 0.1 * max(0.0, this->ref_vs -ahead.ref_vs);
        goal_vs = max(0.0, goal_vs - 0.2 * (1 + extra_dec));

    } else if (goal_vs < TARGET_SPEED - 0.3) {
        goal_vs += 0.2;
    }

    traj_set = trajectory_points(goals, goal_vs);

    return traj_set;
}

vector<vector<vector<double>>> Vehicle::lane_change_trajectory(string state, const map<int, Vehicle> &round_vehicles) {
    /*
    Generate parameters of a lane change trajectory.
    */
    vector<tk::spline> lines;
    Vehicle next_lane_vehicle;
    vector<vector<vector<double>>> traj_set;

    //Check if a lane change is possible (check if another vehicle occupies that spot).
    for (auto it = round_vehicles.begin(); it != round_vehicles.end(); ++it) {
        next_lane_vehicle = it->second;
        if ( abs(next_lane_vehicle.s - this->s) < 5 && next_lane_vehicle.ref_lane == this->heading_lane()) {
            //If lane change is not possible, return empty trajectory.
            return traj_set;
        }
    }

    vector<vector<vector<double>>> goals = get_goal_positions(round_vehicles, this->heading_lane());

    double goal_vs = ref_vs;
    goal_vs = min(goal_vs + 0.2, TARGET_SPEED);   //while change lane, speed up
    traj_set = trajectory_points(goals, goal_vs);

    return traj_set;
}

vector<vector<vector<double>>> Vehicle::trajectory_points(vector<vector<vector<double>>> goals_sets, double goal_vs) {
    vector<vector<vector<double>>> traj_set;

    for(auto &goals:goals_sets) {
        vector<double> ptsx;
        vector<double> ptsy;
        //previous point before ref_x,y
        ptsx.push_back(spline_x_pos[0]);
        ptsx.push_back(spline_x_pos[1]);
        ptsx.push_back(goals[0][0]);
        ptsx.push_back(goals[1][0]);
        ptsx.push_back(goals[2][0]);
        ptsy.push_back(spline_y_pos[0]);
        ptsy.push_back(spline_y_pos[1]);
        ptsy.push_back(goals[0][1]);
        ptsy.push_back(goals[1][1]);
        ptsy.push_back(goals[2][1]);

        //goal_pos around car_s + 30, car_s + 60, car_s + 90
        for (int i = 0; i < ptsx.size(); i++) {
            double shift_x = ptsx[i] - ref_x;
            double shift_y = ptsy[i] - ref_y;

            vector<double> p = gobal2car_cor(shift_x, shift_y);

            ptsx[i] = p[0];
            ptsy[i] = p[1];
        }
/*        cout << "spline_x_pos: " << ptsx[0] << "," << ptsx[1] << ","
             << ptsx[2] << "," << ptsx[3] << "," << ptsx[4] << endl;*/
        tk::spline s;
        s.set_points(ptsx, ptsy); //gen spline for each goals_set

        //gen trajectory using the spline
        double target_x = 30.0;
        double target_y = s(target_x);
        double target_dist = sqrt(target_x*target_x + target_y* target_y);

        double N = target_dist/(0.02*goal_vs);

        vector<double> next_x_vals;
        vector<double> next_y_vals;

        //cout << "pred_num: " << pred_num << endl;
        for (int i = 0; i< pred_num; i++) {
            double x_point = (i + 1) * target_x/N;
            double y_point = s(x_point);

            vector<double> point = car2global_cor(x_point, y_point);
            x_point = ref_x + point[0];
            y_point = ref_y + point[1];
            next_x_vals.push_back(x_point);
            next_y_vals.push_back(y_point);
            //cout << "new xy: " << x_point << ", " << y_point << endl;
        }

        traj_set.push_back({next_x_vals, next_y_vals});    //trajectory for each goals_set
    }
    return traj_set;
}

vector<double> Vehicle::car2global_cor(double x, double y) {
    return {x * cos(ref_yaw) - y * sin(ref_yaw),
            x * sin(ref_yaw) + y * cos(ref_yaw)};
}

vector<double> Vehicle::gobal2car_cor(double x, double y) {
    return {x * cos(ref_yaw) + y * sin(ref_yaw),
            -x * sin(ref_yaw) + y * cos(ref_yaw)};
}

vector<vector<vector<double>>> Vehicle::get_goal_positions(const map<int, Vehicle> &round_vehicles,
                                                   int lane) {
    //cout << "get_goal_positions" << endl;
    vector<vector<vector<double>>> goals_xy;

    //perturb goals
    default_random_engine gen;
    normal_distribution<double> distrib(0, 1);
    vector<double> goal_s = {30, 60, 90};

    for (int i = 0; i < N_SAMPLES; i++) {
        //perturb goals
/*        goal_s[0] = this->s + 30 + distrib(gen);
        goal_s[1] = this->s + 60 + distrib(gen);
        goal_s[2] = this->s + 90 + distrib(gen); */
        goal_s[0] = this->s + 30 + 30*abs(lane-ref_lane); //if change lane, we want slow down vd
        goal_s[1] = this->s + 60 + 20*abs(lane-ref_lane);
        goal_s[2] = this->s + 90 + 10*abs(lane-ref_lane); 
        
        vector<double> p3= getXY(goal_s[0], (4 *lane + 2), map_waypoints_s, map_waypoints_x, map_waypoints_y);
        vector<double> p4= getXY(goal_s[1], (4 *lane + 2), map_waypoints_s, map_waypoints_x, map_waypoints_y);
        vector<double> p5= getXY(goal_s[2], (4 *lane + 2), map_waypoints_s, map_waypoints_x, map_waypoints_y);
            
        goals_xy.push_back({p3, p4, p5});
        //cout << "goal: " << goal[0] << ", " << goal[1] << endl;
    }
    return goals_xy;
}

double Vehicle::target_lane_speed(const map<int, Vehicle> & round_vehicles,
                         int target_lane) const {
    vector<double> speed_section = _lane_speed_section(round_vehicles, target_lane);
    double min_lane_speed = speed_section[0];
    double max_lane_speed = speed_section[1];

    if (max_lane_speed < 0 && min_lane_speed < 0) {
    //no vehicle ahead or behind limit the velocity
        return TARGET_SPEED;
    }
    else if (max_lane_speed >= min_lane_speed && min_lane_speed >= 0) {
    //both ahead or behind vehicle limit the velocity
        return max_lane_speed;
    }
    else if (max_lane_speed >= 0 && min_lane_speed < 0) {
    //only ahead vehicle limit the velocity
        return min(TARGET_SPEED , max_lane_speed);
    }
    else if (min_lane_speed >= 0 && max_lane_speed < 0) {
    //only behind vehicle limit the velocity
        return max(TARGET_SPEED , min_lane_speed);
    }
    else
    //max_lane_speed < min_lane_speed means the behind car maybe want a lane change, maybe continue waitting
        return TARGET_SPEED/2;
}

vector<double> Vehicle::_lane_speed_section(const map<int, Vehicle> & round_vehicles,
                          int lane) const {
    Vehicle ahead, behind;
    double max_lane_speed = -1.0;
    double min_lane_speed = -1.0;
    if (this->get_vehicle_ahead(round_vehicles, lane, ahead)) {
        max_lane_speed = ahead.ref_vs;
    }
    if (this->get_vehicle_behind(round_vehicles, lane, behind)) {
        min_lane_speed = behind.ref_vs;
    }
    vector<double> speed_section = {min_lane_speed, max_lane_speed};

    return speed_section;
}

int Vehicle::heading_lane() const {
    if (this->state == "KL")
        return this->ref_lane;
    else if (this->state == "LCR" || this->state == "PLCR")
        return this->ref_lane + 1;
    else if (this->state == "LCL" || this->state == "PLCL")
        return this->ref_lane - 1;
}

bool Vehicle::get_vehicle_behind(const map<int, Vehicle> &round_vehicles,
                                 int lane, Vehicle & rVehicle) const {
    /*
    Returns a true if a vehicle is found behind the current vehicle, false otherwise. The passed reference
    rVehicle is updated if a vehicle is found.
    */
    double max_s;
    bool found_vehicle = false;
    Vehicle temp_vehicle;
    for (auto it = round_vehicles.begin(); it != round_vehicles.end(); ++it) {
        temp_vehicle = it->second;
        if (temp_vehicle.ref_lane == this->ref_lane && temp_vehicle.ref_s < this->ref_s) {
            max_s = temp_vehicle.s;
            rVehicle = temp_vehicle;
            found_vehicle = true;
        }
    }
    return found_vehicle;
}

bool Vehicle::get_vehicle_ahead(const map<int, Vehicle> & round_vehicles,
                                int lane, Vehicle & rVehicle) const {
    /*
    Returns a true if a vehicle is found ahead of the current vehicle, false otherwise. The passed reference
    rVehicle is updated if a vehicle is found.
    */
    double min_s;
    bool found_vehicle = false;
    Vehicle temp_vehicle;
    for (auto it = round_vehicles.begin(); it != round_vehicles.end(); ++it) {
        temp_vehicle = it->second;
        if (temp_vehicle.ref_lane == this->ref_lane && temp_vehicle.ref_s > this->ref_s) {
            min_s = temp_vehicle.s;
            rVehicle = temp_vehicle;
            found_vehicle = true;
        }
    }
    return found_vehicle;
}


double Vehicle::nearest_approach_to_any_vehicle(const vector<vector<double>> &traj_points,
                                                const map<int, Vehicle> & round_vehicles) const{
    double closest = 9999999;
    for(auto &tmp_vehicle:round_vehicles) {
        double d = nearest_approach(traj_points, tmp_vehicle.second);
        if (d < closest)
            closest = d;
    }
    return closest;
}

double Vehicle::nearest_approach(const vector<vector<double>> &traj_points, const Vehicle & vehicle) const{
    double closest = 9999999;
    for(int i = 0; i < pred_num; i++) {
        double ego_x = traj_points[0][i];
        double ego_y = traj_points[1][i];
        vector<double> xy = getXY(vehicle.ref_s + i * TIME_INTERVAL * vehicle.vs,
                                  vehicle.ref_d, map_waypoints_s, map_waypoints_x, map_waypoints_y);

        double dist = distance(ego_x, ego_y, xy[0], xy[1]);
        if (dist < closest)
            closest = dist;
    }
    return closest;
}